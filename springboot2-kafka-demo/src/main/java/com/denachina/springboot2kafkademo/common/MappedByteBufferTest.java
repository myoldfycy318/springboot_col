package com.denachina.springboot2kafkademo.common;import java.io.*;import java.nio.MappedByteBuffer;import java.nio.channels.FileChannel;import java.nio.file.Paths;import java.nio.file.StandardOpenOption;/** * 因为它使用direct buffer的方式读写文件内容，这种方式的学名叫做内存映射。 * 这种方式直接调用系统底层的缓存，没有JVM和系统之间的复制操作，所以效率大大的提高了。 * 而且由于它这么快，还可以用它来在进程（或线程）间传递消息，基本上能达到和“共享内存页”相同的作用， * 只不过它是依托实体文件来运行的。 * <p> * FileChannel提供了map方法来把文件映射为MappedByteBuffer： MappedByteBuffer map(int mode,long position,long size); * 可以把文件从position开始的size大小的区域映射为MappedByteBuffer，mode指出了可访问该内存映像文件的方式，共有三种，分别为： * <p> * MapMode.READ_ONLY（只读）： 试图修改得到的缓冲区将导致抛出 ReadOnlyBufferException。 * MapMode.READ_WRITE（读/写）： 对得到的缓冲区的更改最终将写入文件；但该更改对映射到同一文件的其他程序不一定是可见的（无处不在的“一致性问题”又出现了）。 * MapMode.PRIVATE（专用）： 可读可写,但是修改的内容不会写入文件,只是buffer自身的改变，这种能力称之为”copy on write” * <p> * <p> * 但是MappedByteBuffer也有不足，就是在数据量很小的时候，表现比较糟糕，那是因为direct buffer的初始化时间较长，所以建议大家只有在数据量较大的时候，在用MappedByteBuffer。 * 还要强调的一点是，MappedByteBuffer存在内存占用和文件关闭等不确定问题。被MappedByteBuffer打开的文件只有在垃圾收集时才会被关闭，而这个点是不确定的。javadoc里是这么说的： * A mapped byte buffer and the file mapping that it represents remain valid until the buffer itself is garbage-collected * * @author shanmin.zhang * @date 19/1/29 **/public class MappedByteBufferTest {    public void test() {        //一个byte占1B，所以共向文件中存128M的数据        int length = 0x8000000;        try (FileChannel channel = FileChannel.open(Paths.get("/Users/shanmin.zhang/wokedir/c.txt"),                StandardOpenOption.READ, StandardOpenOption.WRITE)) {            MappedByteBuffer mapBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, length);            for (int i = 0; i < length; i++) {                mapBuffer.put((byte) i);            }            for (int i = length / 2; i < length / 2 + 4; i++) {                //像数组一样访问                System.out.println(mapBuffer.get(i));            }        } catch (IOException e) {            e.printStackTrace();        }    }    //1G    private static int length = 0x2FFFFFFF;    private abstract static class Tester {        private String name;        public Tester(String name) {            this.name = name;        }        public void runTest() {            System.out.print(name + ": ");            long start = System.currentTimeMillis();            test();            System.out.println(System.currentTimeMillis() - start + " ms");        }        public abstract void test();    }    private static Tester[] testers = {            new Tester("Mapped RW") {                @Override                public void test() {                    try (FileChannel channel = FileChannel.open(Paths.get("/Users/shanmin.zhang/wokedir/b.txt"),                            StandardOpenOption.READ, StandardOpenOption.WRITE)) {                        MappedByteBuffer mapBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, length);                        for (int i = 0; i < length; i++) {                            mapBuffer.put((byte) 0);                        }                        mapBuffer.flip();                        while (mapBuffer.hasRemaining()) {                            mapBuffer.get();                        }                    } catch (IOException e) {                        e.printStackTrace();                    }                }            },            new Tester("Mapped PRIVATE") {                @Override                public void test() {                    try (FileChannel channel = FileChannel.open(Paths.get("/Users/shanmin.zhang/wokedir/c.txt"),                            StandardOpenOption.READ, StandardOpenOption.WRITE)) {                        MappedByteBuffer mapBuffer = channel.map(FileChannel.MapMode.PRIVATE, 0, length);                        for (int i = 0; i < length; i++) {                            mapBuffer.put((byte) 0);                        }                        mapBuffer.flip();                        while (mapBuffer.hasRemaining()) {                            mapBuffer.get();                        }                    } catch (IOException e) {                        e.printStackTrace();                    }                }            }    };    public static void main(String[] args) {        for (Tester tester : testers) {            tester.runTest();        }    }}