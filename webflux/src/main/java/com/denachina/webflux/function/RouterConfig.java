package com.denachina.webflux.function;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.HttpStatus;import org.springframework.util.ReflectionUtils;import org.springframework.web.reactive.function.server.*;import reactor.core.publisher.Mono;/** * RouterConfig * * @author shanmin.zhang * @date 18/12/6 **/@SuppressWarnings("ALL")@Configurationpublic class RouterConfig {    @Autowired    private TimeHandler timeHandler;    /**     * 在函数式编程模型中，每个请求是由一个函数来处理的，通过接口org.springframework.web.reactive.function.server.HandlerFunction来表示。     * HandlerFunction是一个函数式接口，其中只有一个方法，因此可以用 Labmda 表达式来实现该接口     * <p>     * 然后通过函数式接口org.springframework.web.reactive.function.server.RouterFunction来为这些HandlerFunction提供路由信息，     * 输入为请求，输出为装在 Mono 里边的Handlerfunction     *     * @return     */    @Bean    public RouterFunction<ServerResponse> timeRouter() {        return RouterFunctions.route(RequestPredicates.GET("/time"), serverRequest -> timeHandler.getTime(serverRequest))                .andRoute(RequestPredicates.GET("/date"), timeHandler::getDate)                .andRoute(RequestPredicates.GET("/times"), timeHandler::sendTimePerSec)                .andRoute(RequestPredicates.GET("/random"), serverRequest -> timeHandler.sendRandomPerSec(serverRequest));    }    /**     * http://127.0.0.1:9091/calculator?operator=add&v1=2&v2=3     *     * @param calculatorHandler     * @return     */    @Bean    @Autowired    public RouterFunction<ServerResponse> routerFunction(final CalculatorHandler calculatorHandler) {        return RouterFunctions.route(RequestPredicates.path("/calculator"), request ->                request.queryParam("operator").map(operator ->                        Mono.justOrEmpty(ReflectionUtils.findMethod(CalculatorHandler.class, operator, ServerRequest.class))                                .flatMap(method -> (Mono<ServerResponse>) ReflectionUtils.invokeMethod(method, calculatorHandler, request))                                .switchIfEmpty(ServerResponse.badRequest().build())                                .onErrorResume(ex -> ServerResponse.status(HttpStatus.INTERNAL_SERVER_ERROR).build())                ).orElse(ServerResponse.badRequest().build())        );    }}